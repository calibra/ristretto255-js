
<!DOCTYPE html>
<html>
  <head>
    <title>Benchmarking ristretto in Javascript</title>
    <link rel="stylesheet" type="text/css" href="ristretto.benchmark.style.css">
    <script src="ristretto.min.js"></script>
  </head>
  <body>

    <div class="container">
      <h1>Benchmarks of ristretto functions</h1>
      <div id="total_time">Rendering benchmarks...</div>
      <h2>Low-level ristretto functions</h2>
      <div class="benchmarks">
      <table class="benchmarks">
	<tr><th>Function name</th><th>Time in ms</th><th>Comments</th></tr>
	<tr><td>ristretto255_random</td><td id="ristretto255_random">0.00</td><td>Generates a random EC-ristretto point by calling from_hash on 64-elements random byte array</td></tr>
	<tr><td>ristretto255_tobytes</td><td id="ristretto255_tobytes">0.00</td><td>Serializes an EC-ristretto point to byte array</td></tr>
	<tr><td>ristretto255_frombytes</td><td id="ristretto255_frombytes">0.00</td><td>Deserializes a byte array to an EC-ristretto point</td></tr>
	<tr><td>ristretto255_from_hash</td><td id="ristretto255_from_hash">0.00</td><td>Generates an EC-ristretto point from a 64 elements byte array such as an output of SHA512</td></tr>
      </table>
      </div>

      <h2>High-level ristretto functions</h2>
      <div class="benchmarks">
      <table class="benchmarks">
	<tr><th>Function name</th><th>Time in ms</th><th>Comments</th></tr>
	<tr><td>crypto_core_ristretto255_random</td><td id="crypto_core_ristretto255_random">0.00</td><td>Generates a random EC-ristretto point and outputs a serialized byte array</td></tr>
	<tr><td>crypto_core_ristretto255_from_hash</td><td id="crypto_core_ristretto255_from_hash">0.00</td><td>Generates an EC-ristretto point from hash and outputs a serialized byte array</td></tr>
	<tr><td>crypto_core_ristretto255_add</td><td id="crypto_core_ristretto255_add">0.00</td><td>Deserializes input byte arrays to EC-ristretto points, adds them up and outputs a serialized result</td></tr>
	<tr><td>crypto_core_ristretto255_sub</td><td id="crypto_core_ristretto255_sub">0.00</td><td>Deserializes input byte arrays to EC-ristretto points, subtracts them up and outputs a serialized result</td></tr>	
	<tr><td>crypto_scalarmult_ristretto255_base</td><td id="crypto_scalarmult_ristretto255_base">0.00</td><td>Multiplies a base EC-ristretto point by a scalar and outputs a serialized result</td></tr>
	<tr><td>crypto_scalarmult_ristretto255</td><td id="crypto_scalarmult_ristretto255">0.00</td><td>Deserializes the input byte array to an EC-ristretto point, multiplies by a scalar and outputs a serialized result</td></tr>
      </table>
      </div>
	
      <h2>High-level EC-ristretto functions</h2>
      <div class="benchmarks">
      <table class="benchmarks">
	<tr><th>Function name</th><th>Time in ms</th><th>Comments</th></tr>
	<tr><td>nacl.lowlevel.add<td id="ADD">0.00</td><td>Add two EC-ristretto points, outputs a resulting EC-ristretto point</td></tr>
	<tr><td>ristretto.sub</td><td id="SUB">0.00</td><td>Sub two EC-ristretto points, outputs a resulting EC-ristretto point</td></tr>
	<tr><td>nacl.lowlevel.scalarbase</td><td id="SCALAR_BASE">0.00</td><td>Multiply a base EC-ristretto point by a scalar, outputs a resulting EC-ristretto point</td></tr>
	<tr><td>nacl.lowlevel.scalarmult</td><td id="SCALAR_MULT">0.00</td><td>Multiply an EC-ristretto point by a scalar, outputs a resulting EC-ristretto point</td></tr>
      </table>
      </div>
      
      <h2>Scalar opeartions</h2>
      <div class="benchmarks">
      <table class="benchmarks">
	<tr><th>Function name</th><th>Time in ms</th><th>Comments</th></tr>
	<tr><td>crypto_core_ristretto255_scalar_random</td><td id="crypto_core_ristretto255_scalar_random">0.00</td><td>Generates a random scalar</td></tr>
	<tr><td>crypto_core_ristretto255_scalar_invert</td><td id="crypto_core_ristretto255_scalar_invert">0.00</td><td>Inverts a scalar</td></tr>
	<tr><td>crypto_core_ristretto255_scalar_negate</td><td id="crypto_core_ristretto255_scalar_negate">0.00</td><td>Negates a scalar</td></tr>
	<tr><td>crypto_core_ristretto255_scalar_add</td><td id="crypto_core_ristretto255_scalar_add">0.00</td><td>Adds two scalars</td></tr>
	<tr><td>crypto_core_ristretto255_scalar_sub</td><td id="crypto_core_ristretto255_scalar_sub">0.00</td><td>Subtracts two scalars</td></tr>
	<tr><td>crypto_core_ristretto255_scalar_mul</td><td id="crypto_core_ristretto255_scalar_mul">0.00</td><td>Multiplies two scalars</td></tr>
      </table>
      </div>
      
      <h2>ECDH with SECP256 from window.crypto</h2>
      <div class="benchmarks">
      <table class="benchmarks">
	<tr><th>Function name</th><th>Time in ms</th><th>Comments</th></tr>
	<tr><td>window.crypto.subtle.generateKey</td><td id="window.crypto.subtle.generateKey">0.00</td><td>Generates a random ECDH key pair with SECP-256. Essentially the same as nacl.lowlevel.scalarbase except on a different curve and 1000 X slower.</td></tr>
	<tr><td>window.crypto.subtle.deriveKey</td><td id="window.crypto.subtle.deriveKey">0.00</td><td>Derive a symmetric key for ECDH with SECP-256. Essentially the same as nacl.lowlevel.scalarmult except on a different curve and 500 X slower.</td></tr>
	
      </table>
      </div>
    </div>
    <!--<div class="discussion">
      - see discussion of which ec curves are safe to use: http://safecurves.cr.yp.to/
      - secp256 curves: typically incomplete addition formulas are used, complete addition formulas exist (https://eprint.iacr.org/2015/1060.pdf), but are about 1.38 times slower.
      (openssl uses  https://github.com/openssl/openssl/blob/7671420d9ebd18242f571866c6adca6f8bcb2f90/crypto/ec/ecp_nistp256.c#L1235 for how it is implemented in OpsnSSL, referencing http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl they do have complete addition formulas with cost: 11M + 5S from http://cr.yp.to/talks.html#2001.10.29).
    </div>-->

    <script>
      /* Set-up */
      var t00 = performance.now();
      var NUM_OF_REPS = 100;
      var ristretto_EC_points = [];
      var ristretto_serialized_points = [];
      var hashes = [];
      var scalars = [];
      var t0, t1;
      /* Generate random ristretto points */
      for (i = 0; i < NUM_OF_REPS; i++) {
	  let ristretto_EC_point = ristretto.ristretto255_random();
	  ristretto_EC_points.push(ristretto_EC_point);
	  ristretto_serialized_points.push(ristretto.ristretto255_tobytes(ristretto_EC_point));
	  hashes.push(new Uint8Array(crypto.subtle.digest("SHA-512", new TextEncoder("utf-8").encode(i + ""))));
	  scalars.push(ristretto.crypto_core_ristretto255_scalar_random());
      }
      /* ristretto255_random */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.ristretto255_random();
      }
      t1 = performance.now();
      document.getElementById("ristretto255_random").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);//.replace(/\B(?=(\d{3})+(?!\d))/g, ",");				
      
      /* ristretto255_tobytes */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.ristretto255_tobytes(ristretto_EC_points[i]);
      }
      t1 = performance.now();
      document.getElementById("ristretto255_tobytes").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* ristretto255_frombytes */
      t0 = performance.now();
      var h = [ristretto.nacl_gf(), ristretto.nacl_gf(), ristretto.nacl_gf(), ristretto.nacl_gf()];
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.ristretto255_frombytes(h, ristretto_serialized_points[i]);
      }
      t1 = performance.now();
      document.getElementById("ristretto255_frombytes").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* ristretto255_from_hash */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.ristretto255_from_hash(hashes[i]);
      }
      t1 = performance.now();
      document.getElementById("ristretto255_from_hash").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* crypto_core_ristretto255_random */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_random();
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_random").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_from_hash */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_from_hash(hashes[i]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_from_hash").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_from_add */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_add(ristretto_serialized_points[i], ristretto_serialized_points[(i + 1) % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_add").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_from_sub */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_sub(ristretto_serialized_points[i], ristretto_serialized_points[(i + 1) % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_sub").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_scalarmult_ristretto255_base */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_scalarmult_ristretto255_base(scalars[i]);
      }
      t1 = performance.now();
      document.getElementById("crypto_scalarmult_ristretto255_base").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_scalarmult_ristretto255 */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_scalarmult_ristretto255(scalars[i], ristretto_serialized_points[i]);
      }
      t1 = performance.now();
      document.getElementById("crypto_scalarmult_ristretto255").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* crypto_core_ristretto255_scalar_random */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_random();
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_random").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_scalar_invert */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_invert(scalars[i]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_invert").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_scalar_negate */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_negate(scalars[i], scalars[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_negate").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_scalar_add */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_add(scalars[i], scalars[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_add").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_scalar_sub */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_sub(scalars[i], scalars[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_sub").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      /* crypto_core_ristretto255_scalar_mul */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.crypto_core_ristretto255_scalar_mul(scalars[i], scalars[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("crypto_core_ristretto255_scalar_mul").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* ADD */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.nacl_add(ristretto_EC_points[i], ristretto_EC_points[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("ADD").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* SUB */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.sub(ristretto_EC_points[i], ristretto_EC_points[i % NUM_OF_REPS]);
      }
      t1 = performance.now();
      document.getElementById("SUB").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* SCALAR_BASE */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.nacl_scalarbase(ristretto_EC_points[i], scalars[i]);
      }
      t1 = performance.now();
      document.getElementById("SCALAR_BASE").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* SCALAR_MULT */
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  ristretto.nacl_scalarmult(ristretto_EC_points[i], ristretto_EC_points[i % NUM_OF_REPS], scalars[i]);
      }
      t1 = performance.now();
      document.getElementById("SCALAR_MULT").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
      
      var t01 = performance.now();
      document.getElementById("total_time").innerHTML = "Benchmark runtime: " + ((t01 - t00)/1000).toFixed(2) + " sec with " + NUM_OF_REPS + " reps on each operation.";

      /* scalar-to-base multiplication over secp256 EC curve */
      // see https://8gwifi.org/docs/window-crypto-ecdh.jsp for a useful tutorial
      var publicKey = {};
      var privateKey = {};
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
	  let keyPair = window.crypto.subtle.generateKey(
	      {
		  name: "ECDH",
		  namedCurve: "P-256"
	      },
	      true, // whether the key is extractable (can be used in exportKey)
	      ["deriveKey", "deriveBits"]
	  ).then(function(key) {
              publicKey.push(key.publicKey);
              privateKey.push(key.privateKey);
	  }).catch(function(err) {
              console.error(err);
	  });
      }
      t1 = performance.now();
      document.getElementById("window.crypto.subtle.generateKey").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);

      /* scalar-to-point multiplication over secp256 EC curve */
      // Actually this is doing more of course... but the bulk of operations should theoretically go to scalar-to-point mul
      t0 = performance.now();
      for (i = 0; i < NUM_OF_REPS; i++) {
      window.crypto.subtle.deriveKey({
                    name: "ECDH",
                    namedCurve: "P-256",
                    public: publicKey[i],
                },
                privateKey[i % NUM_OF_REPS],
                {
                    name: "AES-GCM",
                    length: 256,
                },

           true, // whether the derived key is extractable (i.e. can be used in exportKey)
                ["encrypt", "decrypt"]
            ).catch(function(err) {
                console.error(err);
            });
      }
      t1 = performance.now();
      document.getElementById("window.crypto.subtle.deriveKey").innerHTML = "" + ((t1 - t0)/NUM_OF_REPS).toFixed(3);
    </script>
  </body>
</html>
